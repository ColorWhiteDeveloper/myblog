#### let、var的区别
let 不存在变量提升，var会变量提升，那什么又是变量提升呢，
我们先来看一段代码
```js
console.log(b);
var b = 1;
console.log(a);
let a = 0;
```
上面这段代码b、a是怎么输出的呢？在控制台中，b输出的时undefined；
输出a则是报错。原来啊浏览器会在加载js之前把var、function关键字
进行提前的声明或者定义，这种处理机制就是变量提升。所以当js加载的
时候，b就已经存在了，但是此时还没有进行赋值，所以会输出undefined
，但是let没有像var那样提前声明或者定义，所以输出a就会提示报错。

let 和 var的区别还可以用一个经典的循环例子来展现。
```js
for(var i=0;i<10;i++){
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
for(let j=0;j<10;j++){
    setTimeout(()=>{
        console.log(j);
    },1000)
}
```
当我刚开始学习前端的时候，曾经的我认为两个循环输出的都会是0-9；结果用
var的循环输出的时10个10；这让当时我摸不着头脑。后来接触到代码的执行时间、
以及自执行函数，才对这个例子恍然大悟。在1s之内，循环早执行完了，此时的i
是10，所以会循环输出10个10；但为什么不是10个9呢？那是因为在i=9时，先执行
i++；在执行判断条件，退出循环的时候，i已经变成10了。
用let的循环可以换成下面这种，你就知道原因了。
```js
for(var i=0;i<10;i++){
    (function(i){
        setTimeout(()=>{
            console.log(i);
        },1000)
    })(i);
}
```
所以可以暂时认为let在这个循环中是var的自执行函数.
#### const
const 和 let是ES2015(ES6)推出的；
const 声明一个只读的常量，一旦声明，常量的值就不能改变。但是这并不是绝对的。
```js
const num = 1;
num++;
const str = 'str';
str= 'hello'
const flag = true;
flag = false;
```
上面的一串代码就是声明的只读的常量，而且并不能改变。那么对象呢
```js
const obj = {
    a:1,
}
obj.a = 2;
```
突然发现到，对象中的数值能够改变，那么我可以认为基本数据类型声明就是常量
复杂数据类型则不是，那么原因是为什么呢？原来啊，用const声明复杂数据类型
指向的是它在堆中的地址。所以里面的内容可以随便改变.
#### 暂时性死区
暂时性死区是针对于'const' 和 'let'这两个关键字而产生的概念。
首先变量提升这个js的基本概念无法撼动，'const'和'let'作为块级作用域也不能避免。
和'var'不同，这两个关键字将作用域限制在了‘块’中，且规定了在该块中，由这两个关键字定义的变量已经被分配内存。
即其实已经'存在'了，但程序未执行到声明处时，访问该变量都会报引用错误。
这个时候，对于该变量来说就是'暂时性死区'，通俗来说就是该变量存在，但并未完全存在